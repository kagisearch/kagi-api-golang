/*
Kagi API

The Kagi API provides programmatic access to data that powers our search results & more.   Quick start for all APIs:  - Create an account at [Kagi](https://kagi.com/signup) - Generate an [API key](https://kagi.com/settings?p=api) - Call the API  We have the following APIs available. ### Commercial  - Kagi Search API (invite only at the moment) - Web and News Enrichment API (public, exposes Kagi's own indexes Teclis and TinyGem) - Universal Summarizer API (public) - FastGPT API (public)  ### Free  - Kagi Small Web RSS feed (public)  ### Official Client Libraries  We offer the following libraries you can use to interact with the Kagi API. These are generated from an OpenAPI spec. If you have a language you would like to use and it's not in the list, send us a message and we will add it to the list if it is supported. Or you can use the [spec](https://wild-wombat.redocly.app/_spec/openapi.yaml?download) to build your own custom library.  - [Golang](https://github.com/kagisearch/kagi-api-golang) - [Python](https://github.com/kagisearch/kagi-api-python) - [Rust](https://github.com/kagisearch/kagi-api-rust)  ### Unofficial Client Libraries  There also exist third party libraries for interacting with the Kagi API.  - [kagigo for Go](https://github.com/httpjamesm/kagigo) - FastGPT & Universal Summarizer - [kagi-api](https://crates.io/crates/kagi-api) for Rust - [kagi-api](https://alchemists.io/projects/kagi-api) for Ruby - [kagi-dotnet](https://github.com/patchoulish/kagi-dotnet) for C#/.NET  ### API Status  Our existing API, the \"v0\" beta API, is being replaced with a new version that will be available publicly soon. As changes are made, we will be updating the documentation below when the new features become available.  See the [Support and Community](https://help.kagi.com/kagi/support-and-community/) section for details. ### Pricing  We are in the process of moving all APIs to a post-paid tiered system, where each tier has a limit on the number of requests that can be made. If an API has a pricing section, then it is still being migrated over to the new billing system.  ### GitHub Discussions  This is the preferred venue for bug reports and feature requests.  - [Bug Reports](https://github.com/kagisearch/kagi-docs/issues/new/choose) - [Q&A Forum](https://github.com/kagisearch/kagi-docs/discussions/categories/q-a?discussions_q=category%3AQ%26A+label%3Aproduct%3Akagi_search_api) - [API Feature Requests](https://github.com/kagisearch/kagi-docs/discussions/categories/kagi-search-api-feature-requests-ideas)  ### Discord Join our [Discord](https://kagi.com/discord)! Good for quick questions or chatting about things you've made with our APIs! 

API version: 0.1.0
Contact: support@kagi.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// TranslateAPIService TranslateAPI service
type TranslateAPIService service

type ApiTranslateRequest struct {
	ctx context.Context
	ApiService *TranslateAPIService
	translateRequest *TranslateRequest
}

func (r ApiTranslateRequest) TranslateRequest(translateRequest TranslateRequest) ApiTranslateRequest {
	r.translateRequest = &translateRequest
	return r
}

func (r ApiTranslateRequest) Execute() (*Translate200Response, *http.Response, error) {
	return r.ApiService.TranslateExecute(r)
}

/*
Translate Text Translation

Translates text between languages with customizable options for gender, formality, and style. Supports both single text translation and efficient batch translation of multiple text snippets with context awareness.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTranslateRequest
*/
func (a *TranslateAPIService) Translate(ctx context.Context) ApiTranslateRequest {
	return ApiTranslateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Translate200Response
func (a *TranslateAPIService) TranslateExecute(r ApiTranslateRequest) (*Translate200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Translate200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TranslateAPIService.Translate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/translate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.translateRequest == nil {
		return localVarReturnValue, nil, reportError("translateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/event-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.translateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Translate400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Translate500Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTranslateAlternativesRequest struct {
	ctx context.Context
	ApiService *TranslateAPIService
	originalText *string
	existingTranslation *string
	targetLang *string
	sourceLang *string
	targetExplanationLanguage *string
	translationOptions *string
	partialTranslation *string
}

// Original text to translate. In partial mode, this serves as context for the phrase (may be ignored if not relevant).
func (r ApiTranslateAlternativesRequest) OriginalText(originalText string) ApiTranslateAlternativesRequest {
	r.originalText = &originalText
	return r
}

// In standard mode: existing full translation of the original text. In partial mode: the specific phrase you want alternative ways to express.
func (r ApiTranslateAlternativesRequest) ExistingTranslation(existingTranslation string) ApiTranslateAlternativesRequest {
	r.existingTranslation = &existingTranslation
	return r
}

// Target language code (ISO-639) for the translations
func (r ApiTranslateAlternativesRequest) TargetLang(targetLang string) ApiTranslateAlternativesRequest {
	r.targetLang = &targetLang
	return r
}

// Source language code (ISO-639) of the original text. Helps provide more accurate alternatives by understanding language-specific nuances.
func (r ApiTranslateAlternativesRequest) SourceLang(sourceLang string) ApiTranslateAlternativesRequest {
	r.sourceLang = &sourceLang
	return r
}

// Language code (ISO-639) for the explanations
func (r ApiTranslateAlternativesRequest) TargetExplanationLanguage(targetExplanationLanguage string) ApiTranslateAlternativesRequest {
	r.targetExplanationLanguage = &targetExplanationLanguage
	return r
}

// JSON string with translation customization options: - &#x60;formality&#x60;: Controls formality level [\\\&quot;default\\\&quot;, \\\&quot;more\\\&quot;, \\\&quot;less\\\&quot;] - &#x60;speaker_gender&#x60;: Gender of the speaker [\\\&quot;unknown\\\&quot;, \\\&quot;feminine\\\&quot;, \\\&quot;masculine\\\&quot;, \\\&quot;neutral\\\&quot;] - &#x60;addressee_gender&#x60;: Gender of the person being addressed [\\\&quot;unknown\\\&quot;, \\\&quot;feminine\\\&quot;, \\\&quot;masculine\\\&quot;, \\\&quot;neutral\\\&quot;] - &#x60;style&#x60;: Translation style [\\\&quot;natural\\\&quot;, \\\&quot;literal\\\&quot;] - &#x60;context&#x60;: Additional context to inform translation (string) 
func (r ApiTranslateAlternativesRequest) TranslationOptions(translationOptions string) ApiTranslateAlternativesRequest {
	r.translationOptions = &translationOptions
	return r
}

// Mode switch: &#39;false&#39; for standard mode (full translation alternatives), &#39;true&#39; for partial mode (alternative ways to phrase a specific part)
func (r ApiTranslateAlternativesRequest) PartialTranslation(partialTranslation string) ApiTranslateAlternativesRequest {
	r.partialTranslation = &partialTranslation
	return r
}

func (r ApiTranslateAlternativesRequest) Execute() (*TranslateAlternatives200Response, *http.Response, error) {
	return r.ApiService.TranslateAlternativesExecute(r)
}

/*
TranslateAlternatives Alternative Translations

Provides alternative translation options for a given text with explanations. Supports two modes: standard mode (alternatives for a full translation) and partial mode (alternative ways to phrase a specific part of a translation).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTranslateAlternativesRequest
*/
func (a *TranslateAPIService) TranslateAlternatives(ctx context.Context) ApiTranslateAlternativesRequest {
	return ApiTranslateAlternativesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TranslateAlternatives200Response
func (a *TranslateAPIService) TranslateAlternativesExecute(r ApiTranslateAlternativesRequest) (*TranslateAlternatives200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TranslateAlternatives200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TranslateAPIService.TranslateAlternatives")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alternative-translations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.originalText == nil {
		return localVarReturnValue, nil, reportError("originalText is required and must be specified")
	}
	if r.existingTranslation == nil {
		return localVarReturnValue, nil, reportError("existingTranslation is required and must be specified")
	}
	if r.targetLang == nil {
		return localVarReturnValue, nil, reportError("targetLang is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "original_text", r.originalText, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "existing_translation", r.existingTranslation, "", "")
	if r.sourceLang != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "source_lang", r.sourceLang, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "target_lang", r.targetLang, "", "")
	if r.targetExplanationLanguage != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "target_explanation_language", r.targetExplanationLanguage, "", "")
	}
	if r.translationOptions != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "translation_options", r.translationOptions, "", "")
	}
	if r.partialTranslation != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "partial_translation", r.partialTranslation, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v TranslateAlternatives401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v TranslateAlternatives402Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v TranslateAlternatives500Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTranslateDetectRequest struct {
	ctx context.Context
	ApiService *TranslateAPIService
	translateDetectRequest *TranslateDetectRequest
}

func (r ApiTranslateDetectRequest) TranslateDetectRequest(translateDetectRequest TranslateDetectRequest) ApiTranslateDetectRequest {
	r.translateDetectRequest = &translateDetectRequest
	return r
}

func (r ApiTranslateDetectRequest) Execute() (*TranslateDetect200Response, *http.Response, error) {
	return r.ApiService.TranslateDetectExecute(r)
}

/*
TranslateDetect Language Detection

Detects the language of the provided text.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTranslateDetectRequest
*/
func (a *TranslateAPIService) TranslateDetect(ctx context.Context) ApiTranslateDetectRequest {
	return ApiTranslateDetectRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TranslateDetect200Response
func (a *TranslateAPIService) TranslateDetectExecute(r ApiTranslateDetectRequest) (*TranslateDetect200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TranslateDetect200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TranslateAPIService.TranslateDetect")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/detect"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.translateDetectRequest == nil {
		return localVarReturnValue, nil, reportError("translateDetectRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.translateDetectRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v TranslateDetect400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTranslateDictionaryRequest struct {
	ctx context.Context
	ApiService *TranslateAPIService
	translateDictionaryRequest *TranslateDictionaryRequest
}

func (r ApiTranslateDictionaryRequest) TranslateDictionaryRequest(translateDictionaryRequest TranslateDictionaryRequest) ApiTranslateDictionaryRequest {
	r.translateDictionaryRequest = &translateDictionaryRequest
	return r
}

func (r ApiTranslateDictionaryRequest) Execute() (*TranslateDictionary200Response, *http.Response, error) {
	return r.ApiService.TranslateDictionaryExecute(r)
}

/*
TranslateDictionary Dictionary

Provides dictionary definitions for words in different languages.

**Translation behavior:**
- Fields translated to `definition_language`: definition, notes, etymology, part_of_speech, usage_level, dialect
- Fields that remain in `word_language`: word, synonyms, pronunciation, plural, related_words, examples (with translations in parentheses when languages differ)
- Fields always in English (strict enums): gender ("masculine", "feminine", "neuter", "common"), temporal_trend ("increasing", "stable", "decreasing")


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTranslateDictionaryRequest
*/
func (a *TranslateAPIService) TranslateDictionary(ctx context.Context) ApiTranslateDictionaryRequest {
	return ApiTranslateDictionaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TranslateDictionary200Response
func (a *TranslateAPIService) TranslateDictionaryExecute(r ApiTranslateDictionaryRequest) (*TranslateDictionary200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TranslateDictionary200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TranslateAPIService.TranslateDictionary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/dictionary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.translateDictionaryRequest == nil {
		return localVarReturnValue, nil, reportError("translateDictionaryRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.translateDictionaryRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v TranslateDictionary400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v TranslateDictionary500Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTranslateListLanguagesRequest struct {
	ctx context.Context
	ApiService *TranslateAPIService
	type_ *string
	locale *string
}

// Type of languages to return (&#39;source&#39; or &#39;target&#39;)
func (r ApiTranslateListLanguagesRequest) Type_(type_ string) ApiTranslateListLanguagesRequest {
	r.type_ = &type_
	return r
}

// Locale code to use for language names (e.g., &#39;en&#39;, &#39;de&#39;, &#39;fr&#39;)
func (r ApiTranslateListLanguagesRequest) Locale(locale string) ApiTranslateListLanguagesRequest {
	r.locale = &locale
	return r
}

func (r ApiTranslateListLanguagesRequest) Execute() ([]TranslateListLanguages200ResponseInner, *http.Response, error) {
	return r.ApiService.TranslateListLanguagesExecute(r)
}

/*
TranslateListLanguages List Supported Languages

Returns a list of languages supported by the translation API.

The response includes language codes, names, and whether each language supports formality settings.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTranslateListLanguagesRequest
*/
func (a *TranslateAPIService) TranslateListLanguages(ctx context.Context) ApiTranslateListLanguagesRequest {
	return ApiTranslateListLanguagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []TranslateListLanguages200ResponseInner
func (a *TranslateAPIService) TranslateListLanguagesExecute(r ApiTranslateListLanguagesRequest) ([]TranslateListLanguages200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TranslateListLanguages200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TranslateAPIService.TranslateListLanguages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/list-languages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ExampleError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTranslateRomanizeRequest struct {
	ctx context.Context
	ApiService *TranslateAPIService
	text *string
	language *string
}

// Text to romanize
func (r ApiTranslateRomanizeRequest) Text(text string) ApiTranslateRomanizeRequest {
	r.text = &text
	return r
}

// Language code (ISO-639) of the source text
func (r ApiTranslateRomanizeRequest) Language(language string) ApiTranslateRomanizeRequest {
	r.language = &language
	return r
}

func (r ApiTranslateRomanizeRequest) Execute() (*TranslateRomanize200Response, *http.Response, error) {
	return r.ApiService.TranslateRomanizeExecute(r)
}

/*
TranslateRomanize Text Romanization

Converts non-Latin script text to Latin script (romanization/transliteration). Uses standardized romanization styles for each language: Hepburn for Japanese, Pinyin for Chinese, ALA-LC for Arabic, etc.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTranslateRomanizeRequest
*/
func (a *TranslateAPIService) TranslateRomanize(ctx context.Context) ApiTranslateRomanizeRequest {
	return ApiTranslateRomanizeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TranslateRomanize200Response
func (a *TranslateAPIService) TranslateRomanizeExecute(r ApiTranslateRomanizeRequest) (*TranslateRomanize200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TranslateRomanize200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TranslateAPIService.TranslateRomanize")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/romanize"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.text == nil {
		return localVarReturnValue, nil, reportError("text is required and must be specified")
	}
	if r.language == nil {
		return localVarReturnValue, nil, reportError("language is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "language", r.language, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v TranslateDetect400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTranslateWordInsightsRequest struct {
	ctx context.Context
	ApiService *TranslateAPIService
	originalText *string
	translatedText *string
	targetExplanationLanguage *string
	translationOptions *string
}

// Source text that was translated
func (r ApiTranslateWordInsightsRequest) OriginalText(originalText string) ApiTranslateWordInsightsRequest {
	r.originalText = &originalText
	return r
}

// Translated text to analyze for linguistic insights
func (r ApiTranslateWordInsightsRequest) TranslatedText(translatedText string) ApiTranslateWordInsightsRequest {
	r.translatedText = &translatedText
	return r
}

// Language code (ISO-639) for the explanations and type labels
func (r ApiTranslateWordInsightsRequest) TargetExplanationLanguage(targetExplanationLanguage string) ApiTranslateWordInsightsRequest {
	r.targetExplanationLanguage = &targetExplanationLanguage
	return r
}

// Optional JSON string with translation options that provide context for the insights. Can include formality, gender preferences, and style. 
func (r ApiTranslateWordInsightsRequest) TranslationOptions(translationOptions string) ApiTranslateWordInsightsRequest {
	r.translationOptions = &translationOptions
	return r
}

func (r ApiTranslateWordInsightsRequest) Execute() (*TranslateWordInsights200Response, *http.Response, error) {
	return r.ApiService.TranslateWordInsightsExecute(r)
}

/*
TranslateWordInsights Word Insights

Provides detailed linguistic insights and alternatives for translated text. The API identifies 3-5 key
words or phrases in the translated text that have meaningful alternative expressions, and returns:

1. A marked version of the translation with insight markers
2. Alternative expressions for each identified word/phrase
3. Brief explanations for each alternative in the target explanation language
4. Type labels categorizing each insight (e.g., "Lexical choice", "Cultural reference")


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTranslateWordInsightsRequest
*/
func (a *TranslateAPIService) TranslateWordInsights(ctx context.Context) ApiTranslateWordInsightsRequest {
	return ApiTranslateWordInsightsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TranslateWordInsights200Response
func (a *TranslateAPIService) TranslateWordInsightsExecute(r ApiTranslateWordInsightsRequest) (*TranslateWordInsights200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TranslateWordInsights200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TranslateAPIService.TranslateWordInsights")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/word-insights"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.originalText == nil {
		return localVarReturnValue, nil, reportError("originalText is required and must be specified")
	}
	if r.translatedText == nil {
		return localVarReturnValue, nil, reportError("translatedText is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "original_text", r.originalText, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "translated_text", r.translatedText, "", "")
	if r.targetExplanationLanguage != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "target_explanation_language", r.targetExplanationLanguage, "", "")
	}
	if r.translationOptions != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "translation_options", r.translationOptions, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v TranslateWordInsights400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v TranslateAlternatives401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v TranslateAlternatives402Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v TranslateWordInsights500Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

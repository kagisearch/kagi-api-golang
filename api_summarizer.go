/*
Kagi API

The search API provides programmatic access to data that powers our search results & more. Kagi APIs  We have the following APIs available. ### Commercial  - Kagi Search API (invite only at the moment) - Web and News Enrichment API (public, exposes Kagi's own indexes Teclis and TinyGem) - Universal Summarizer API (public) - FastGPT API (public)  Quick start for all APIs:  - Get the API key (requires a Kagi account). - Top off your API credits. - Call the API.  ### Free  - Kagi Small Web RSS feed (public)  ### Unofficial Client Libraries  Libraries created by Kagi users and third parties.  - kagigo for Go - FastGPT & Universal Summarizer - kagi-api for Rust - kagi-dotnet for C#/.NET  ### Beta Status  The API is currently in a \"v0\" beta status. Changes will be ongoing, and will be added to the documentation below as features become available.  Use at your own risk, but please reach out to us if you have any questions.  See the Support and Community section for details. ### GitHub Discussions  This is the preferred venue for bug reports and feature requests.  - Bug Reports - Q&A Forum - API Feature Requests  ### Discord Join our Discord! Good for quick questions, chatting about thing you've made with our APIs! 

API version: 0.0.0
Contact: support@kagi.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// SummarizerAPIService SummarizerAPI service
type SummarizerAPIService service

type ApiSummarizeTextRequest struct {
	ctx context.Context
	ApiService *SummarizerAPIService
	uploadText *UploadText
	engine *string
	summaryType *string
	targetLanguage *string
	cache *bool
}

// Text to summarize
func (r ApiSummarizeTextRequest) UploadText(uploadText UploadText) ApiSummarizeTextRequest {
	r.uploadText = &uploadText
	return r
}

// Different summarization engines are provided that will give you choices over the \&quot;flavor\&quot; of the summarization text.
func (r ApiSummarizeTextRequest) Engine(engine string) ApiSummarizeTextRequest {
	r.engine = &engine
	return r
}

// Different summary types are provided that control the structure of the summary output.
func (r ApiSummarizeTextRequest) SummaryType(summaryType string) ApiSummarizeTextRequest {
	r.summaryType = &summaryType
	return r
}

// The summarizer can translate the output into a desired language, using the table of supported language codes below.  If no language is specified, the document&#39;s original language is allowed to influence the summarizer&#39;s output. Specifying a language will add an explicit translation step, to translate the summary to the desired language.  For example, if a document is mostly written in Spanish, the summary output may itself be in Spanish or contain Spanish passages. Specifying \&quot;EN\&quot; will ensure all passages are translated as English. 
func (r ApiSummarizeTextRequest) TargetLanguage(targetLanguage string) ApiSummarizeTextRequest {
	r.targetLanguage = &targetLanguage
	return r
}

// Whether to allow cached requests &amp; responses.
func (r ApiSummarizeTextRequest) Cache(cache bool) ApiSummarizeTextRequest {
	r.cache = &cache
	return r
}

func (r ApiSummarizeTextRequest) Execute() (*Summary, *http.Response, error) {
	return r.ApiService.SummarizeTextExecute(r)
}

/*
SummarizeText Upload text to summarize.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSummarizeTextRequest
*/
func (a *SummarizerAPIService) SummarizeText(ctx context.Context) ApiSummarizeTextRequest {
	return ApiSummarizeTextRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Summary
func (a *SummarizerAPIService) SummarizeTextExecute(r ApiSummarizeTextRequest) (*Summary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Summary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SummarizerAPIService.SummarizeText")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/summarize"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.uploadText == nil {
		return localVarReturnValue, nil, reportError("uploadText is required and must be specified")
	}

	if r.engine != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "engine", r.engine, "form", "")
	} else {
		var defaultValue string = "cecil"
		r.engine = &defaultValue
	}
	if r.summaryType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summary_type", r.summaryType, "form", "")
	} else {
		var defaultValue string = "summary"
		r.summaryType = &defaultValue
	}
	if r.targetLanguage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "target_language", r.targetLanguage, "form", "")
	}
	if r.cache != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cache", r.cache, "form", "")
	} else {
		var defaultValue bool = true
		r.cache = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.uploadText
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["kagi"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ExampleError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSummarizeURLRequest struct {
	ctx context.Context
	ApiService *SummarizerAPIService
	url *string
	engine *string
	summaryType *string
	targetLanguage *string
	cache *bool
}

// A URL to a document to summarize.
func (r ApiSummarizeURLRequest) Url(url string) ApiSummarizeURLRequest {
	r.url = &url
	return r
}

// Different summarization engines are provided that will give you choices over the \&quot;flavor\&quot; of the summarization text.
func (r ApiSummarizeURLRequest) Engine(engine string) ApiSummarizeURLRequest {
	r.engine = &engine
	return r
}

// Different summary types are provided that control the structure of the summary output.
func (r ApiSummarizeURLRequest) SummaryType(summaryType string) ApiSummarizeURLRequest {
	r.summaryType = &summaryType
	return r
}

// The summarizer can translate the output into a desired language, using the table of supported language codes below.  If no language is specified, the document&#39;s original language is allowed to influence the summarizer&#39;s output. Specifying a language will add an explicit translation step, to translate the summary to the desired language.  For example, if a document is mostly written in Spanish, the summary output may itself be in Spanish or contain Spanish passages. Specifying \&quot;EN\&quot; will ensure all passages are translated as English. 
func (r ApiSummarizeURLRequest) TargetLanguage(targetLanguage string) ApiSummarizeURLRequest {
	r.targetLanguage = &targetLanguage
	return r
}

// Whether to allow cached requests &amp; responses.
func (r ApiSummarizeURLRequest) Cache(cache bool) ApiSummarizeURLRequest {
	r.cache = &cache
	return r
}

func (r ApiSummarizeURLRequest) Execute() (*Summary, *http.Response, error) {
	return r.ApiService.SummarizeURLExecute(r)
}

/*
SummarizeURL Get a summary for a URL

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSummarizeURLRequest
*/
func (a *SummarizerAPIService) SummarizeURL(ctx context.Context) ApiSummarizeURLRequest {
	return ApiSummarizeURLRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Summary
func (a *SummarizerAPIService) SummarizeURLExecute(r ApiSummarizeURLRequest) (*Summary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Summary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SummarizerAPIService.SummarizeURL")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/summarize"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.url == nil {
		return localVarReturnValue, nil, reportError("url is required and must be specified")
	}

	if r.engine != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "engine", r.engine, "form", "")
	} else {
		var defaultValue string = "cecil"
		r.engine = &defaultValue
	}
	if r.summaryType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summary_type", r.summaryType, "form", "")
	} else {
		var defaultValue string = "summary"
		r.summaryType = &defaultValue
	}
	if r.targetLanguage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "target_language", r.targetLanguage, "form", "")
	}
	if r.cache != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cache", r.cache, "form", "")
	} else {
		var defaultValue bool = true
		r.cache = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "url", r.url, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["kagi"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ExampleError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
Kagi API

The Kagi API provides programmatic access to data that powers our search results & more.   Quick start for all APIs:  - Create an account at [Kagi](https://kagi.com/signup) - Generate an [API key](https://kagi.com/settings?p=api) - Call the API  We have the following APIs available. ### Commercial  - Kagi Search API (invite only at the moment) - Web and News Enrichment API (public, exposes Kagi's own indexes Teclis and TinyGem) - Universal Summarizer API (public) - FastGPT API (public)  ### Free  - Kagi Small Web RSS feed (public)  ### Official Client Libraries  We offer the following libraries you can use to interact with the Kagi API. These are generated from an OpenAPI spec. If you have a language you would like to use and it's not in the list, send us a message and we will add it to the list if it is supported. Or you can use the [spec](https://wild-wombat.redocly.app/_spec/openapi.yaml?download) to build your own custom library.  - [Golang](https://github.com/kagisearch/kagi-api-golang) - [Python](https://github.com/kagisearch/kagi-api-python) - [Rust](https://github.com/kagisearch/kagi-api-rust)  ### Unofficial Client Libraries  There also exist third party libraries for interacting with the Kagi API.  - [kagigo for Go](https://github.com/httpjamesm/kagigo) - FastGPT & Universal Summarizer - [kagi-api](https://crates.io/crates/kagi-api) for Rust - [kagi-api](https://alchemists.io/projects/kagi-api) for Ruby - [kagi-dotnet](https://github.com/patchoulish/kagi-dotnet) for C#/.NET  ### API Status  Our existing API, the \"v0\" beta API, is being replaced with a new version that will be available publicly soon. As changes are made, we will be updating the documentation below when the new features become available.  See the [Support and Community](https://help.kagi.com/kagi/support-and-community/) section for details. ### Pricing  We are in the process of moving all APIs to a post-paid tiered system, where each tier has a limit on the number of requests that can be made. If an API has a pricing section, then it is still being migrated over to the new billing system.  ### GitHub Discussions  This is the preferred venue for bug reports and feature requests.  - [Bug Reports](https://github.com/kagisearch/kagi-docs/issues/new/choose) - [Q&A Forum](https://github.com/kagisearch/kagi-docs/discussions/categories/q-a?discussions_q=category%3AQ%26A+label%3Aproduct%3Akagi_search_api) - [API Feature Requests](https://github.com/kagisearch/kagi-docs/discussions/categories/kagi-search-api-feature-requests-ideas)  ### Discord Join our [Discord](https://kagi.com/discord)! Good for quick questions or chatting about things you've made with our APIs! 

API version: 0.1.0
Contact: support@kagi.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// SummarizerAPIService SummarizerAPI service
type SummarizerAPIService service

type ApiSummarizeTextRequest struct {
	ctx context.Context
	ApiService *SummarizerAPIService
	uploadText *UploadText
	engine *string
	summaryType *string
	targetLanguage *string
	cache *bool
}

// Text to summarize
func (r ApiSummarizeTextRequest) UploadText(uploadText UploadText) ApiSummarizeTextRequest {
	r.uploadText = &uploadText
	return r
}

// Different summarization engines are provided that will give you choices over the \&quot;flavor\&quot; of the summarization text.
func (r ApiSummarizeTextRequest) Engine(engine string) ApiSummarizeTextRequest {
	r.engine = &engine
	return r
}

// Different summary types are provided that control the structure of the summary output.
func (r ApiSummarizeTextRequest) SummaryType(summaryType string) ApiSummarizeTextRequest {
	r.summaryType = &summaryType
	return r
}

// The summarizer can translate the output into a desired language, using the table of supported language codes below.  If no language is specified, the document&#39;s original language is allowed to influence the summarizer&#39;s output. Specifying a language will add an explicit translation step, to translate the summary to the desired language.  For example, if a document is mostly written in Spanish, the summary output may itself be in Spanish or contain Spanish passages. Specifying \&quot;EN\&quot; will ensure all passages are translated as English. 
func (r ApiSummarizeTextRequest) TargetLanguage(targetLanguage string) ApiSummarizeTextRequest {
	r.targetLanguage = &targetLanguage
	return r
}

// Whether to allow cached requests &amp; responses.
func (r ApiSummarizeTextRequest) Cache(cache bool) ApiSummarizeTextRequest {
	r.cache = &cache
	return r
}

func (r ApiSummarizeTextRequest) Execute() (*Summary, *http.Response, error) {
	return r.ApiService.SummarizeTextExecute(r)
}

/*
SummarizeText Upload text to summarize.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSummarizeTextRequest
*/
func (a *SummarizerAPIService) SummarizeText(ctx context.Context) ApiSummarizeTextRequest {
	return ApiSummarizeTextRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Summary
func (a *SummarizerAPIService) SummarizeTextExecute(r ApiSummarizeTextRequest) (*Summary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Summary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SummarizerAPIService.SummarizeText")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/summarize"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.uploadText == nil {
		return localVarReturnValue, nil, reportError("uploadText is required and must be specified")
	}

	if r.engine != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "engine", r.engine, "form", "")
	} else {
		var defaultValue string = "cecil"
		r.engine = &defaultValue
	}
	if r.summaryType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summary_type", r.summaryType, "form", "")
	} else {
		var defaultValue string = "summary"
		r.summaryType = &defaultValue
	}
	if r.targetLanguage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "target_language", r.targetLanguage, "form", "")
	}
	if r.cache != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cache", r.cache, "form", "")
	} else {
		var defaultValue bool = true
		r.cache = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.uploadText
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["kagi"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ExampleError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSummarizeURLRequest struct {
	ctx context.Context
	ApiService *SummarizerAPIService
	url *string
	engine *string
	summaryType *string
	targetLanguage *string
	cache *bool
}

// A URL to a document to summarize.
func (r ApiSummarizeURLRequest) Url(url string) ApiSummarizeURLRequest {
	r.url = &url
	return r
}

// Different summarization engines are provided that will give you choices over the \&quot;flavor\&quot; of the summarization text.
func (r ApiSummarizeURLRequest) Engine(engine string) ApiSummarizeURLRequest {
	r.engine = &engine
	return r
}

// Different summary types are provided that control the structure of the summary output.
func (r ApiSummarizeURLRequest) SummaryType(summaryType string) ApiSummarizeURLRequest {
	r.summaryType = &summaryType
	return r
}

// The summarizer can translate the output into a desired language, using the table of supported language codes below.  If no language is specified, the document&#39;s original language is allowed to influence the summarizer&#39;s output. Specifying a language will add an explicit translation step, to translate the summary to the desired language.  For example, if a document is mostly written in Spanish, the summary output may itself be in Spanish or contain Spanish passages. Specifying \&quot;EN\&quot; will ensure all passages are translated as English. 
func (r ApiSummarizeURLRequest) TargetLanguage(targetLanguage string) ApiSummarizeURLRequest {
	r.targetLanguage = &targetLanguage
	return r
}

// Whether to allow cached requests &amp; responses.
func (r ApiSummarizeURLRequest) Cache(cache bool) ApiSummarizeURLRequest {
	r.cache = &cache
	return r
}

func (r ApiSummarizeURLRequest) Execute() (*Summary, *http.Response, error) {
	return r.ApiService.SummarizeURLExecute(r)
}

/*
SummarizeURL Get a summary for a URL

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSummarizeURLRequest
*/
func (a *SummarizerAPIService) SummarizeURL(ctx context.Context) ApiSummarizeURLRequest {
	return ApiSummarizeURLRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Summary
func (a *SummarizerAPIService) SummarizeURLExecute(r ApiSummarizeURLRequest) (*Summary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Summary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SummarizerAPIService.SummarizeURL")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/summarize"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.url == nil {
		return localVarReturnValue, nil, reportError("url is required and must be specified")
	}

	if r.engine != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "engine", r.engine, "form", "")
	} else {
		var defaultValue string = "cecil"
		r.engine = &defaultValue
	}
	if r.summaryType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summary_type", r.summaryType, "form", "")
	} else {
		var defaultValue string = "summary"
		r.summaryType = &defaultValue
	}
	if r.targetLanguage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "target_language", r.targetLanguage, "form", "")
	}
	if r.cache != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cache", r.cache, "form", "")
	} else {
		var defaultValue bool = true
		r.cache = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "url", r.url, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["kagi"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ExampleError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

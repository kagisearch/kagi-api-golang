/*
Kagi API

The search API provides programmatic access to data that powers our search results & more. Kagi APIs  We have the following APIs available. ### Commercial  - Kagi Search API (invite only at the moment) - Web and News Enrichment API (public, exposes Kagi's own indexes Teclis and TinyGem) - Universal Summarizer API (public) - FastGPT API (public)  Quick start for all APIs:  - Get the API key (requires a Kagi account). - Top off your API credits. - Call the API.  ### Free  - Kagi Small Web RSS feed (public)  ### Unofficial Client Libraries  Libraries created by Kagi users and third parties.  - kagigo for Go - FastGPT & Universal Summarizer - kagi-api for Rust - kagi-dotnet for C#/.NET  ### Beta Status  The API is currently in a \"v0\" beta status. Changes will be ongoing, and will be added to the documentation below as features become available.  Use at your own risk, but please reach out to us if you have any questions.  See the Support and Community section for details. ### GitHub Discussions  This is the preferred venue for bug reports and feature requests.  - Bug Reports - Q&A Forum - API Feature Requests  ### Discord Join our Discord! Good for quick questions, chatting about thing you've made with our APIs! 

API version: 0.0.0
Contact: support@kagi.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"os"
)


// TranslateAPIService TranslateAPI service
type TranslateAPIService service

type ApiTranslateAlternativesRequest struct {
	ctx context.Context
	ApiService *TranslateAPIService
	originalText *string
	existingTranslation *string
	targetLang *string
	sourceLang *string
	targetExplanationLanguage *string
	translationOptions *string
	partialTranslation *string
}

// Original text to translate. In partial mode, this serves as context for the phrase (may be ignored if not relevant).
func (r ApiTranslateAlternativesRequest) OriginalText(originalText string) ApiTranslateAlternativesRequest {
	r.originalText = &originalText
	return r
}

// In standard mode: existing full translation of the original text. In partial mode: the specific phrase you want alternative ways to express.
func (r ApiTranslateAlternativesRequest) ExistingTranslation(existingTranslation string) ApiTranslateAlternativesRequest {
	r.existingTranslation = &existingTranslation
	return r
}

// Target language code (ISO-639) for the translations
func (r ApiTranslateAlternativesRequest) TargetLang(targetLang string) ApiTranslateAlternativesRequest {
	r.targetLang = &targetLang
	return r
}

// Source language code (ISO-639) of the original text. Helps provide more accurate alternatives by understanding language-specific nuances.
func (r ApiTranslateAlternativesRequest) SourceLang(sourceLang string) ApiTranslateAlternativesRequest {
	r.sourceLang = &sourceLang
	return r
}

// Language code (ISO-639) for the explanations
func (r ApiTranslateAlternativesRequest) TargetExplanationLanguage(targetExplanationLanguage string) ApiTranslateAlternativesRequest {
	r.targetExplanationLanguage = &targetExplanationLanguage
	return r
}

// JSON string with translation customization options: - &#x60;formality&#x60;: Controls formality level [\\\&quot;default\\\&quot;, \\\&quot;more\\\&quot;, \\\&quot;less\\\&quot;] - &#x60;speaker_gender&#x60;: Gender of the speaker [\\\&quot;unknown\\\&quot;, \\\&quot;feminine\\\&quot;, \\\&quot;masculine\\\&quot;, \\\&quot;neutral\\\&quot;] - &#x60;addressee_gender&#x60;: Gender of the person being addressed [\\\&quot;unknown\\\&quot;, \\\&quot;feminine\\\&quot;, \\\&quot;masculine\\\&quot;, \\\&quot;neutral\\\&quot;] - &#x60;style&#x60;: Translation style [\\\&quot;natural\\\&quot;, \\\&quot;literal\\\&quot;] - &#x60;context&#x60;: Additional context to inform translation (string) 
func (r ApiTranslateAlternativesRequest) TranslationOptions(translationOptions string) ApiTranslateAlternativesRequest {
	r.translationOptions = &translationOptions
	return r
}

// Mode switch: &#39;false&#39; for standard mode (full translation alternatives), &#39;true&#39; for partial mode (alternative ways to phrase a specific part)
func (r ApiTranslateAlternativesRequest) PartialTranslation(partialTranslation string) ApiTranslateAlternativesRequest {
	r.partialTranslation = &partialTranslation
	return r
}

func (r ApiTranslateAlternativesRequest) Execute() (*TranslateAlternatives200Response, *http.Response, error) {
	return r.ApiService.TranslateAlternativesExecute(r)
}

/*
TranslateAlternatives Alternative Translations

Provides alternative translation options for a given text with explanations. Supports two modes: standard mode (alternatives for a full translation) and partial mode (alternative ways to phrase a specific part of a translation).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTranslateAlternativesRequest
*/
func (a *TranslateAPIService) TranslateAlternatives(ctx context.Context) ApiTranslateAlternativesRequest {
	return ApiTranslateAlternativesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TranslateAlternatives200Response
func (a *TranslateAPIService) TranslateAlternativesExecute(r ApiTranslateAlternativesRequest) (*TranslateAlternatives200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TranslateAlternatives200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TranslateAPIService.TranslateAlternatives")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/alternative-translations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.originalText == nil {
		return localVarReturnValue, nil, reportError("originalText is required and must be specified")
	}
	if r.existingTranslation == nil {
		return localVarReturnValue, nil, reportError("existingTranslation is required and must be specified")
	}
	if r.targetLang == nil {
		return localVarReturnValue, nil, reportError("targetLang is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "original_text", r.originalText, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "existing_translation", r.existingTranslation, "", "")
	if r.sourceLang != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "source_lang", r.sourceLang, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "target_lang", r.targetLang, "", "")
	if r.targetExplanationLanguage != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "target_explanation_language", r.targetExplanationLanguage, "", "")
	}
	if r.translationOptions != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "translation_options", r.translationOptions, "", "")
	}
	if r.partialTranslation != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "partial_translation", r.partialTranslation, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v TranslateAlternatives401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v TranslateAlternatives402Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v TranslateAlternatives500Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTranslateDetectRequest struct {
	ctx context.Context
	ApiService *TranslateAPIService
	translateDetectRequest *TranslateDetectRequest
}

func (r ApiTranslateDetectRequest) TranslateDetectRequest(translateDetectRequest TranslateDetectRequest) ApiTranslateDetectRequest {
	r.translateDetectRequest = &translateDetectRequest
	return r
}

func (r ApiTranslateDetectRequest) Execute() (*TranslateDetectGet200Response, *http.Response, error) {
	return r.ApiService.TranslateDetectExecute(r)
}

/*
TranslateDetect Language Detection

Detects the language of the provided text.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTranslateDetectRequest
*/
func (a *TranslateAPIService) TranslateDetect(ctx context.Context) ApiTranslateDetectRequest {
	return ApiTranslateDetectRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TranslateDetectGet200Response
func (a *TranslateAPIService) TranslateDetectExecute(r ApiTranslateDetectRequest) (*TranslateDetectGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TranslateDetectGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TranslateAPIService.TranslateDetect")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/detect"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.translateDetectRequest == nil {
		return localVarReturnValue, nil, reportError("translateDetectRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.translateDetectRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v TranslateDetectGet400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTranslateDetectGetRequest struct {
	ctx context.Context
	ApiService *TranslateAPIService
	text *string
}

// Text to detect language from
func (r ApiTranslateDetectGetRequest) Text(text string) ApiTranslateDetectGetRequest {
	r.text = &text
	return r
}

func (r ApiTranslateDetectGetRequest) Execute() (*TranslateDetectGet200Response, *http.Response, error) {
	return r.ApiService.TranslateDetectGetExecute(r)
}

/*
TranslateDetectGet Language Detection API

Detects the language of the provided text.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTranslateDetectGetRequest
*/
func (a *TranslateAPIService) TranslateDetectGet(ctx context.Context) ApiTranslateDetectGetRequest {
	return ApiTranslateDetectGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TranslateDetectGet200Response
func (a *TranslateAPIService) TranslateDetectGetExecute(r ApiTranslateDetectGetRequest) (*TranslateDetectGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TranslateDetectGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TranslateAPIService.TranslateDetectGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/detect"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.text == nil {
		return localVarReturnValue, nil, reportError("text is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v TranslateDetectGet400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTranslateDictionaryRequest struct {
	ctx context.Context
	ApiService *TranslateAPIService
	translateDictionaryRequest *TranslateDictionaryRequest
}

func (r ApiTranslateDictionaryRequest) TranslateDictionaryRequest(translateDictionaryRequest TranslateDictionaryRequest) ApiTranslateDictionaryRequest {
	r.translateDictionaryRequest = &translateDictionaryRequest
	return r
}

func (r ApiTranslateDictionaryRequest) Execute() (*TranslateDictionary200Response, *http.Response, error) {
	return r.ApiService.TranslateDictionaryExecute(r)
}

/*
TranslateDictionary Dictionary

Provides dictionary definitions for words in different languages.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTranslateDictionaryRequest
*/
func (a *TranslateAPIService) TranslateDictionary(ctx context.Context) ApiTranslateDictionaryRequest {
	return ApiTranslateDictionaryRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TranslateDictionary200Response
func (a *TranslateAPIService) TranslateDictionaryExecute(r ApiTranslateDictionaryRequest) (*TranslateDictionary200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TranslateDictionary200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TranslateAPIService.TranslateDictionary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/dictionary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.translateDictionaryRequest == nil {
		return localVarReturnValue, nil, reportError("translateDictionaryRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.translateDictionaryRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v TranslateDictionary400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v TranslateDictionary500Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTranslateFileRequest struct {
	ctx context.Context
	ApiService *TranslateAPIService
	file *os.File
	from *string
	to *string
	isMultiLanguage *bool
	additionalLanguages *[]string
}

// The file to translate. Supported formats include: - Microsoft Word (.doc, .docx) - Text (.txt) - CSV spreadsheets (.csv) - Markdown (.md) 
func (r ApiTranslateFileRequest) File(file *os.File) ApiTranslateFileRequest {
	r.file = file
	return r
}

// Source language code (ISO-639) or \\\&quot;auto\\\&quot; for automatic detection
func (r ApiTranslateFileRequest) From(from string) ApiTranslateFileRequest {
	r.from = &from
	return r
}

// Target language code (ISO-639)
func (r ApiTranslateFileRequest) To(to string) ApiTranslateFileRequest {
	r.to = &to
	return r
}

// If true, creates a file with multiple languages side by side
func (r ApiTranslateFileRequest) IsMultiLanguage(isMultiLanguage bool) ApiTranslateFileRequest {
	r.isMultiLanguage = &isMultiLanguage
	return r
}

// Additional target languages for multi-language translation
func (r ApiTranslateFileRequest) AdditionalLanguages(additionalLanguages []string) ApiTranslateFileRequest {
	r.additionalLanguages = &additionalLanguages
	return r
}

func (r ApiTranslateFileRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.TranslateFileExecute(r)
}

/*
TranslateFile File Translation

Translates documents between languages while preserving their formatting.

**Note: This endpoint will be deprecated in the future and its functionality will be moved to the main /api/translate endpoint.**


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTranslateFileRequest
*/
func (a *TranslateAPIService) TranslateFile(ctx context.Context) ApiTranslateFileRequest {
	return ApiTranslateFileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return *os.File
func (a *TranslateAPIService) TranslateFileExecute(r ApiTranslateFileRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TranslateAPIService.TranslateFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/translate-file"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.file == nil {
		return localVarReturnValue, nil, reportError("file is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileLocalVarFormFileName string
	var fileLocalVarFileName     string
	var fileLocalVarFileBytes    []byte

	fileLocalVarFormFileName = "file"
	fileLocalVarFile := r.file

	if fileLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileLocalVarFile)

		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	}
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "from", r.from, "", "")
	}
	if r.to != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "to", r.to, "", "")
	}
	if r.isMultiLanguage != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "isMultiLanguage", r.isMultiLanguage, "", "")
	}
	if r.additionalLanguages != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "additionalLanguages", r.additionalLanguages, "", "csv")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v TranslateFile400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v TranslateAlternatives401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v TranslateAlternatives402Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v TranslateFile403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v TranslateFile415Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v TranslateFile500Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTranslateListLanguagesRequest struct {
	ctx context.Context
	ApiService *TranslateAPIService
	type_ *string
	locale *string
}

// Type of languages to return (&#39;source&#39; or &#39;target&#39;)
func (r ApiTranslateListLanguagesRequest) Type_(type_ string) ApiTranslateListLanguagesRequest {
	r.type_ = &type_
	return r
}

// Locale code to use for language names (e.g., &#39;en&#39;, &#39;de&#39;, &#39;fr&#39;)
func (r ApiTranslateListLanguagesRequest) Locale(locale string) ApiTranslateListLanguagesRequest {
	r.locale = &locale
	return r
}

func (r ApiTranslateListLanguagesRequest) Execute() ([]TranslateListLanguages200ResponseInner, *http.Response, error) {
	return r.ApiService.TranslateListLanguagesExecute(r)
}

/*
TranslateListLanguages List Supported Languages

Returns a list of languages supported by the translation API.

The response includes language codes, names, and whether each language supports formality settings.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTranslateListLanguagesRequest
*/
func (a *TranslateAPIService) TranslateListLanguages(ctx context.Context) ApiTranslateListLanguagesRequest {
	return ApiTranslateListLanguagesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []TranslateListLanguages200ResponseInner
func (a *TranslateAPIService) TranslateListLanguagesExecute(r ApiTranslateListLanguagesRequest) ([]TranslateListLanguages200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TranslateListLanguages200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TranslateAPIService.TranslateListLanguages")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/list-languages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ExampleError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTranslateListLanguagesPostRequest struct {
	ctx context.Context
	ApiService *TranslateAPIService
	translateListLanguagesPostRequest *TranslateListLanguagesPostRequest
}

func (r ApiTranslateListLanguagesPostRequest) TranslateListLanguagesPostRequest(translateListLanguagesPostRequest TranslateListLanguagesPostRequest) ApiTranslateListLanguagesPostRequest {
	r.translateListLanguagesPostRequest = &translateListLanguagesPostRequest
	return r
}

func (r ApiTranslateListLanguagesPostRequest) Execute() ([]Language, *http.Response, error) {
	return r.ApiService.TranslateListLanguagesPostExecute(r)
}

/*
TranslateListLanguagesPost List Supported Languages API (POST method)

Returns a list of languages supported by the translation API using POST method.

The response includes language codes, names, and whether each language supports formality settings.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTranslateListLanguagesPostRequest
*/
func (a *TranslateAPIService) TranslateListLanguagesPost(ctx context.Context) ApiTranslateListLanguagesPostRequest {
	return ApiTranslateListLanguagesPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []Language
func (a *TranslateAPIService) TranslateListLanguagesPostExecute(r ApiTranslateListLanguagesPostRequest) ([]Language, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Language
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TranslateAPIService.TranslateListLanguagesPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/list-languages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.translateListLanguagesPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ExampleError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTranslateProofReadRequest struct {
	ctx context.Context
	ApiService *TranslateAPIService
	translateProofReadRequest *TranslateProofReadRequest
}

func (r ApiTranslateProofReadRequest) TranslateProofReadRequest(translateProofReadRequest TranslateProofReadRequest) ApiTranslateProofReadRequest {
	r.translateProofReadRequest = &translateProofReadRequest
	return r
}

func (r ApiTranslateProofReadRequest) Execute() (*TranslateProofReadGet200Response, *http.Response, error) {
	return r.ApiService.TranslateProofReadExecute(r)
}

/*
TranslateProofRead Text Proofreading

Proofreads text to correct grammar, spelling, punctuation, and style issues. Returns the corrected text along with detailed explanations of each change, tone analysis, voice consistency, and repetition detection.

**ALPHA STATUS**: This endpoint is in alpha state and may change more frequently than other endpoints. The response format, parameters, or behavior might be modified in future releases.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTranslateProofReadRequest
*/
func (a *TranslateAPIService) TranslateProofRead(ctx context.Context) ApiTranslateProofReadRequest {
	return ApiTranslateProofReadRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TranslateProofReadGet200Response
func (a *TranslateAPIService) TranslateProofReadExecute(r ApiTranslateProofReadRequest) (*TranslateProofReadGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TranslateProofReadGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TranslateAPIService.TranslateProofRead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/proofread"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.translateProofReadRequest == nil {
		return localVarReturnValue, nil, reportError("translateProofReadRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/event-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.translateProofReadRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v TranslateProofReadGet400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v TranslateProofReadGet500Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTranslateProofReadGetRequest struct {
	ctx context.Context
	ApiService *TranslateAPIService
	text *string
	sourceLang *string
	explanationLanguage *string
	stream *bool
}

// Text content to proofread
func (r ApiTranslateProofReadGetRequest) Text(text string) ApiTranslateProofReadGetRequest {
	r.text = &text
	return r
}

// Source language code (ISO-639) or \&quot;auto\&quot; for automatic detection
func (r ApiTranslateProofReadGetRequest) SourceLang(sourceLang string) ApiTranslateProofReadGetRequest {
	r.sourceLang = &sourceLang
	return r
}

// Language code (ISO-639) for explanations and analysis. If not provided, explanations will be in the same language as the source text.
func (r ApiTranslateProofReadGetRequest) ExplanationLanguage(explanationLanguage string) ApiTranslateProofReadGetRequest {
	r.explanationLanguage = &explanationLanguage
	return r
}

// Whether to stream the response as Server-Sent Events
func (r ApiTranslateProofReadGetRequest) Stream(stream bool) ApiTranslateProofReadGetRequest {
	r.stream = &stream
	return r
}

func (r ApiTranslateProofReadGetRequest) Execute() (*TranslateProofReadGet200Response, *http.Response, error) {
	return r.ApiService.TranslateProofReadGetExecute(r)
}

/*
TranslateProofReadGet Text Proofreading API

Proofreads text to correct grammar, spelling, punctuation, and style issues. Returns the corrected text along with detailed explanations of each change, tone analysis, voice consistency, and repetition detection.

**ALPHA STATUS**: This endpoint is in alpha state and may change more frequently than other endpoints. The response format, parameters, or behavior might be modified in future releases.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTranslateProofReadGetRequest
*/
func (a *TranslateAPIService) TranslateProofReadGet(ctx context.Context) ApiTranslateProofReadGetRequest {
	return ApiTranslateProofReadGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TranslateProofReadGet200Response
func (a *TranslateAPIService) TranslateProofReadGetExecute(r ApiTranslateProofReadGetRequest) (*TranslateProofReadGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TranslateProofReadGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TranslateAPIService.TranslateProofReadGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/proofread"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.text == nil {
		return localVarReturnValue, nil, reportError("text is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "form", "")
	if r.sourceLang != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "source_lang", r.sourceLang, "form", "")
	}
	if r.explanationLanguage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "explanation_language", r.explanationLanguage, "form", "")
	}
	if r.stream != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stream", r.stream, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v TranslateProofReadGet400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v TranslateProofReadGet500Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTranslateRomanizeRequest struct {
	ctx context.Context
	ApiService *TranslateAPIService
	text *string
	language *string
}

// Text to romanize
func (r ApiTranslateRomanizeRequest) Text(text string) ApiTranslateRomanizeRequest {
	r.text = &text
	return r
}

// Language code (ISO-639) of the source text
func (r ApiTranslateRomanizeRequest) Language(language string) ApiTranslateRomanizeRequest {
	r.language = &language
	return r
}

func (r ApiTranslateRomanizeRequest) Execute() (*TranslateRomanize200Response, *http.Response, error) {
	return r.ApiService.TranslateRomanizeExecute(r)
}

/*
TranslateRomanize Text Romanization

Converts non-Latin script text to Latin script (romanization/transliteration). Uses standardized romanization styles for each language: Hepburn for Japanese, Pinyin for Chinese, ALA-LC for Arabic, etc.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTranslateRomanizeRequest
*/
func (a *TranslateAPIService) TranslateRomanize(ctx context.Context) ApiTranslateRomanizeRequest {
	return ApiTranslateRomanizeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TranslateRomanize200Response
func (a *TranslateAPIService) TranslateRomanizeExecute(r ApiTranslateRomanizeRequest) (*TranslateRomanize200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TranslateRomanize200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TranslateAPIService.TranslateRomanize")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/romanize"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.text == nil {
		return localVarReturnValue, nil, reportError("text is required and must be specified")
	}
	if r.language == nil {
		return localVarReturnValue, nil, reportError("language is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "language", r.language, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v TranslateDetectGet400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTranslateSpeechRequest struct {
	ctx context.Context
	ApiService *TranslateAPIService
	text *string
	language *string
	voice *string
	raw *bool
}

// Text to convert to speech
func (r ApiTranslateSpeechRequest) Text(text string) ApiTranslateSpeechRequest {
	r.text = &text
	return r
}

// Language code (ISO-639) for speech synthesis. The API supports a wide range of languages and automatically applies appropriate voice prompts for each language.
func (r ApiTranslateSpeechRequest) Language(language string) ApiTranslateSpeechRequest {
	r.language = &language
	return r
}

// Voice to use for speech synthesis
func (r ApiTranslateSpeechRequest) Voice(voice string) ApiTranslateSpeechRequest {
	r.voice = &voice
	return r
}

// If true, returns the raw audio stream without WAV header processing
func (r ApiTranslateSpeechRequest) Raw(raw bool) ApiTranslateSpeechRequest {
	r.raw = &raw
	return r
}

func (r ApiTranslateSpeechRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.TranslateSpeechExecute(r)
}

/*
TranslateSpeech Text-to-Speech

Converts text to natural-sounding speech audio.

Supports multiple languages and voices, with audio delivered in WAV format at 24kHz sample rate.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTranslateSpeechRequest
*/
func (a *TranslateAPIService) TranslateSpeech(ctx context.Context) ApiTranslateSpeechRequest {
	return ApiTranslateSpeechRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return *os.File
func (a *TranslateAPIService) TranslateSpeechExecute(r ApiTranslateSpeechRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TranslateAPIService.TranslateSpeech")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/speech"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.text == nil {
		return localVarReturnValue, nil, reportError("text is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "form", "")
	if r.language != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "language", r.language, "form", "")
	}
	if r.voice != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "voice", r.voice, "form", "")
	} else {
		var defaultValue string = "coral"
		r.voice = &defaultValue
	}
	if r.raw != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "raw", r.raw, "form", "")
	} else {
		var defaultValue bool = false
		r.raw = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"audio/x-wav", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v TranslateSpeech400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v TranslateAlternatives401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v TranslateSpeech402Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTranslateTextAlignmentsRequest struct {
	ctx context.Context
	ApiService *TranslateAPIService
	sourceText *string
	targetText *string
}

// Source text to align
func (r ApiTranslateTextAlignmentsRequest) SourceText(sourceText string) ApiTranslateTextAlignmentsRequest {
	r.sourceText = &sourceText
	return r
}

// Target text to align with the source
func (r ApiTranslateTextAlignmentsRequest) TargetText(targetText string) ApiTranslateTextAlignmentsRequest {
	r.targetText = &targetText
	return r
}

func (r ApiTranslateTextAlignmentsRequest) Execute() (*TranslateTextAlignments200Response, *http.Response, error) {
	return r.ApiService.TranslateTextAlignmentsExecute(r)
}

/*
TranslateTextAlignments Text Alignments

Returns word and phrase alignment data between source and target texts, breaking down the texts into corresponding segments.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTranslateTextAlignmentsRequest
*/
func (a *TranslateAPIService) TranslateTextAlignments(ctx context.Context) ApiTranslateTextAlignmentsRequest {
	return ApiTranslateTextAlignmentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TranslateTextAlignments200Response
func (a *TranslateAPIService) TranslateTextAlignmentsExecute(r ApiTranslateTextAlignmentsRequest) (*TranslateTextAlignments200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TranslateTextAlignments200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TranslateAPIService.TranslateTextAlignments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/text-alignments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sourceText == nil {
		return localVarReturnValue, nil, reportError("sourceText is required and must be specified")
	}
	if r.targetText == nil {
		return localVarReturnValue, nil, reportError("targetText is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "source_text", r.sourceText, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "target_text", r.targetText, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v TranslateTextAlignments400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v TranslateAlternatives402Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTranslateTransacribeRequest struct {
	ctx context.Context
	ApiService *TranslateAPIService
	body *os.File
	language *string
}

func (r ApiTranslateTransacribeRequest) Body(body *os.File) ApiTranslateTransacribeRequest {
	r.body = body
	return r
}

// Language code (ISO-639) of the audio content. Use \&quot;auto\&quot; for automatic language detection. Specifying the correct language can improve transcription accuracy. 
func (r ApiTranslateTransacribeRequest) Language(language string) ApiTranslateTransacribeRequest {
	r.language = &language
	return r
}

func (r ApiTranslateTransacribeRequest) Execute() (*TranslateTransacribe200Response, *http.Response, error) {
	return r.ApiService.TranslateTransacribeExecute(r)
}

/*
TranslateTransacribe Audio Transcription

Converts audio speech into accurate text transcriptions. This API accepts various audio formats and
can automatically detect the spoken language or use a specified language parameter for improved accuracy.

The service processes the audio through a high-quality speech recognition model optimized for clarity and accuracy.
Audio is temporarily stored for processing, then immediately deleted after transcription is complete.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTranslateTransacribeRequest
*/
func (a *TranslateAPIService) TranslateTransacribe(ctx context.Context) ApiTranslateTransacribeRequest {
	return ApiTranslateTransacribeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TranslateTransacribe200Response
func (a *TranslateAPIService) TranslateTransacribeExecute(r ApiTranslateTransacribeRequest) (*TranslateTransacribe200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TranslateTransacribe200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TranslateAPIService.TranslateTransacribe")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/transcribe"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.language != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "language", r.language, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"audio/*"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v TranslateTransacribe400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v TranslateAlternatives401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 415 {
			var v TranslateTransacribe415Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v TranslateTransacribe500Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTranslateWordInsightsRequest struct {
	ctx context.Context
	ApiService *TranslateAPIService
	originalText *string
	translatedText *string
	targetExplanationLanguage *string
	translationOptions *string
}

// Source text that was translated
func (r ApiTranslateWordInsightsRequest) OriginalText(originalText string) ApiTranslateWordInsightsRequest {
	r.originalText = &originalText
	return r
}

// Translated text to analyze for linguistic insights
func (r ApiTranslateWordInsightsRequest) TranslatedText(translatedText string) ApiTranslateWordInsightsRequest {
	r.translatedText = &translatedText
	return r
}

// Language code (ISO-639) for the explanations and type labels
func (r ApiTranslateWordInsightsRequest) TargetExplanationLanguage(targetExplanationLanguage string) ApiTranslateWordInsightsRequest {
	r.targetExplanationLanguage = &targetExplanationLanguage
	return r
}

// Optional JSON string with translation options that provide context for the insights. Can include formality, gender preferences, and style. 
func (r ApiTranslateWordInsightsRequest) TranslationOptions(translationOptions string) ApiTranslateWordInsightsRequest {
	r.translationOptions = &translationOptions
	return r
}

func (r ApiTranslateWordInsightsRequest) Execute() (*TranslateWordInsights200Response, *http.Response, error) {
	return r.ApiService.TranslateWordInsightsExecute(r)
}

/*
TranslateWordInsights Word Insights

Provides detailed linguistic insights and alternatives for translated text. The API identifies 3-5 key
words or phrases in the translated text that have meaningful alternative expressions, and returns:

1. A marked version of the translation with insight markers
2. Alternative expressions for each identified word/phrase
3. Brief explanations for each alternative in the target explanation language
4. Type labels categorizing each insight (e.g., "Lexical choice", "Cultural reference")


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTranslateWordInsightsRequest
*/
func (a *TranslateAPIService) TranslateWordInsights(ctx context.Context) ApiTranslateWordInsightsRequest {
	return ApiTranslateWordInsightsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TranslateWordInsights200Response
func (a *TranslateAPIService) TranslateWordInsightsExecute(r ApiTranslateWordInsightsRequest) (*TranslateWordInsights200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TranslateWordInsights200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TranslateAPIService.TranslateWordInsights")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/word-insights"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.originalText == nil {
		return localVarReturnValue, nil, reportError("originalText is required and must be specified")
	}
	if r.translatedText == nil {
		return localVarReturnValue, nil, reportError("translatedText is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "original_text", r.originalText, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "translated_text", r.translatedText, "", "")
	if r.targetExplanationLanguage != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "target_explanation_language", r.targetExplanationLanguage, "", "")
	}
	if r.translationOptions != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "translation_options", r.translationOptions, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v TranslateWordInsights400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v TranslateAlternatives401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 402 {
			var v TranslateAlternatives402Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v TranslateWordInsights500Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
Kagi API

The Kagi API provides programmatic access to data that powers our search results & more.   Quick start for all APIs:  - Create an account at [Kagi](https://kagi.com/signup) - Generate an [API key](https://kagi.com/settings?p=api) - Call the API  We have the following APIs available. ### Commercial  - Kagi Search API (invite only at the moment) - Web and News Enrichment API (public, exposes Kagi's own indexes Teclis and TinyGem) - Universal Summarizer API (public) - FastGPT API (public)  ### Free  - Kagi Small Web RSS feed (public)  ### Official Client Libraries  We offer the following libraries you can use to interact with the Kagi API. These are generated from an OpenAPI spec. If you have a language you would like to use and it's not in the list, send us a message and we will add it to the list if it is supported. Or you can use the [spec](https://wild-wombat.redocly.app/_spec/openapi.yaml?download) to build your own custom library.  - [Golang](https://github.com/kagisearch/kagi-api-golang) - [Python](https://github.com/kagisearch/kagi-api-python) - [Rust](https://github.com/kagisearch/kagi-api-rust)  ### Unofficial Client Libraries  There also exist third party libraries for interacting with the Kagi API.  - [kagigo for Go](https://github.com/httpjamesm/kagigo) - FastGPT & Universal Summarizer - [kagi-api](https://crates.io/crates/kagi-api) for Rust - [kagi-api](https://alchemists.io/projects/kagi-api) for Ruby - [kagi-dotnet](https://github.com/patchoulish/kagi-dotnet) for C#/.NET  ### API Status  Our existing API, the \"v0\" beta API, is being replaced with a new version that will be available publicly soon. As changes are made, we will be updating the documentation below when the new features become available.  See the [Support and Community](https://help.kagi.com/kagi/support-and-community/) section for details. ### Pricing  We are in the process of moving all APIs to a post-paid tiered system, where each tier has a limit on the number of requests that can be made. If an API has a pricing section, then it is still being migrated over to the new billing system.  ### GitHub Discussions  This is the preferred venue for bug reports and feature requests.  - [Bug Reports](https://github.com/kagisearch/kagi-docs/issues/new/choose) - [Q&A Forum](https://github.com/kagisearch/kagi-docs/discussions/categories/q-a?discussions_q=category%3AQ%26A+label%3Aproduct%3Akagi_search_api) - [API Feature Requests](https://github.com/kagisearch/kagi-docs/discussions/categories/kagi-search-api-feature-requests-ideas)  ### Discord Join our [Discord](https://kagi.com/discord)! Good for quick questions or chatting about things you've made with our APIs! 

API version: 0.1.0
Contact: support@kagi.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"bytes"
	"fmt"
)

// checks if the SearchRequest type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &SearchRequest{}

// SearchRequest Used to upload the search query
type SearchRequest struct {
	// The search query to perform.
	Query string `json:"query"`
	// Can be used to filter result output to a single category.
	Workflow *string `json:"workflow,omitempty"`
	// A lens ID, as shown on https://kagi.com/settings/lenses when a lens is set to be shareable. Can be just the ID portion of the URL (`https://kagi.com/lenses/ID`), or the full URL.
	LensId *string `json:"lens_id,omitempty"`
	Lens *SearchRequestLens `json:"lens,omitempty"`
	// Number of seconds to allow for collecting search results. Lower values will return results more quickly, but may be lower quality or inconsistent between calls. If omitted, will use the latest recommended value by Kagi.
	Timeout *float32 `json:"timeout,omitempty"`
}

type _SearchRequest SearchRequest

// NewSearchRequest instantiates a new SearchRequest object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewSearchRequest(query string) *SearchRequest {
	this := SearchRequest{}
	this.Query = query
	var workflow string = "search"
	this.Workflow = &workflow
	return &this
}

// NewSearchRequestWithDefaults instantiates a new SearchRequest object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewSearchRequestWithDefaults() *SearchRequest {
	this := SearchRequest{}
	var workflow string = "search"
	this.Workflow = &workflow
	return &this
}

// GetQuery returns the Query field value
func (o *SearchRequest) GetQuery() string {
	if o == nil {
		var ret string
		return ret
	}

	return o.Query
}

// GetQueryOk returns a tuple with the Query field value
// and a boolean to check if the value has been set.
func (o *SearchRequest) GetQueryOk() (*string, bool) {
	if o == nil {
		return nil, false
	}
	return &o.Query, true
}

// SetQuery sets field value
func (o *SearchRequest) SetQuery(v string) {
	o.Query = v
}

// GetWorkflow returns the Workflow field value if set, zero value otherwise.
func (o *SearchRequest) GetWorkflow() string {
	if o == nil || IsNil(o.Workflow) {
		var ret string
		return ret
	}
	return *o.Workflow
}

// GetWorkflowOk returns a tuple with the Workflow field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *SearchRequest) GetWorkflowOk() (*string, bool) {
	if o == nil || IsNil(o.Workflow) {
		return nil, false
	}
	return o.Workflow, true
}

// HasWorkflow returns a boolean if a field has been set.
func (o *SearchRequest) HasWorkflow() bool {
	if o != nil && !IsNil(o.Workflow) {
		return true
	}

	return false
}

// SetWorkflow gets a reference to the given string and assigns it to the Workflow field.
func (o *SearchRequest) SetWorkflow(v string) {
	o.Workflow = &v
}

// GetLensId returns the LensId field value if set, zero value otherwise.
func (o *SearchRequest) GetLensId() string {
	if o == nil || IsNil(o.LensId) {
		var ret string
		return ret
	}
	return *o.LensId
}

// GetLensIdOk returns a tuple with the LensId field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *SearchRequest) GetLensIdOk() (*string, bool) {
	if o == nil || IsNil(o.LensId) {
		return nil, false
	}
	return o.LensId, true
}

// HasLensId returns a boolean if a field has been set.
func (o *SearchRequest) HasLensId() bool {
	if o != nil && !IsNil(o.LensId) {
		return true
	}

	return false
}

// SetLensId gets a reference to the given string and assigns it to the LensId field.
func (o *SearchRequest) SetLensId(v string) {
	o.LensId = &v
}

// GetLens returns the Lens field value if set, zero value otherwise.
func (o *SearchRequest) GetLens() SearchRequestLens {
	if o == nil || IsNil(o.Lens) {
		var ret SearchRequestLens
		return ret
	}
	return *o.Lens
}

// GetLensOk returns a tuple with the Lens field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *SearchRequest) GetLensOk() (*SearchRequestLens, bool) {
	if o == nil || IsNil(o.Lens) {
		return nil, false
	}
	return o.Lens, true
}

// HasLens returns a boolean if a field has been set.
func (o *SearchRequest) HasLens() bool {
	if o != nil && !IsNil(o.Lens) {
		return true
	}

	return false
}

// SetLens gets a reference to the given SearchRequestLens and assigns it to the Lens field.
func (o *SearchRequest) SetLens(v SearchRequestLens) {
	o.Lens = &v
}

// GetTimeout returns the Timeout field value if set, zero value otherwise.
func (o *SearchRequest) GetTimeout() float32 {
	if o == nil || IsNil(o.Timeout) {
		var ret float32
		return ret
	}
	return *o.Timeout
}

// GetTimeoutOk returns a tuple with the Timeout field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *SearchRequest) GetTimeoutOk() (*float32, bool) {
	if o == nil || IsNil(o.Timeout) {
		return nil, false
	}
	return o.Timeout, true
}

// HasTimeout returns a boolean if a field has been set.
func (o *SearchRequest) HasTimeout() bool {
	if o != nil && !IsNil(o.Timeout) {
		return true
	}

	return false
}

// SetTimeout gets a reference to the given float32 and assigns it to the Timeout field.
func (o *SearchRequest) SetTimeout(v float32) {
	o.Timeout = &v
}

func (o SearchRequest) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o SearchRequest) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	toSerialize["query"] = o.Query
	if !IsNil(o.Workflow) {
		toSerialize["workflow"] = o.Workflow
	}
	if !IsNil(o.LensId) {
		toSerialize["lens_id"] = o.LensId
	}
	if !IsNil(o.Lens) {
		toSerialize["lens"] = o.Lens
	}
	if !IsNil(o.Timeout) {
		toSerialize["timeout"] = o.Timeout
	}
	return toSerialize, nil
}

func (o *SearchRequest) UnmarshalJSON(data []byte) (err error) {
	// This validates that all required properties are included in the JSON object
	// by unmarshalling the object into a generic map with string keys and checking
	// that every required field exists as a key in the generic map.
	requiredProperties := []string{
		"query",
	}

	allProperties := make(map[string]interface{})

	err = json.Unmarshal(data, &allProperties)

	if err != nil {
		return err;
	}

	for _, requiredProperty := range(requiredProperties) {
		if _, exists := allProperties[requiredProperty]; !exists {
			return fmt.Errorf("no value given for required property %v", requiredProperty)
		}
	}

	varSearchRequest := _SearchRequest{}

	decoder := json.NewDecoder(bytes.NewReader(data))
	decoder.DisallowUnknownFields()
	err = decoder.Decode(&varSearchRequest)

	if err != nil {
		return err
	}

	*o = SearchRequest(varSearchRequest)

	return err
}

type NullableSearchRequest struct {
	value *SearchRequest
	isSet bool
}

func (v NullableSearchRequest) Get() *SearchRequest {
	return v.value
}

func (v *NullableSearchRequest) Set(val *SearchRequest) {
	v.value = val
	v.isSet = true
}

func (v NullableSearchRequest) IsSet() bool {
	return v.isSet
}

func (v *NullableSearchRequest) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableSearchRequest(val *SearchRequest) *NullableSearchRequest {
	return &NullableSearchRequest{value: val, isSet: true}
}

func (v NullableSearchRequest) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableSearchRequest) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


